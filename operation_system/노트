(week1)
  프로세서 구성요소
    레지스타,연산장치 = 데이터부분
    제어장치 = 제어 부분

  레지스터 종류
    사용자 가시 :
      데이터 레지스터 DR : 함수 연산에 필요한 데이터 값 저장, 산술 연산이나 논리 연산에 사용
      주소 레지스터 AR 종류 - 기준 주소 레지스터, 인덱스 레지스터, 스택 포인터 레지스터
    사용자 불가시 :
      프로그램 카운터 PC : 다음에 실행할 명령어의 주소를 보관하는 레지스터
      명령어 레지스터 IR: 현재 실행하는 명령어를 보관하는 레지스터
      누산기 AC: 데이터를 일시적으로 저장하는 레지스터
      메모리 주소 레지스터 MAR: 프로세스가 참조하려는 데이터의 주소를 명시하여 메모리에 접근하는 버퍼 레지스터
      메모리 버퍼 레지스터 MBR: 프로세서가 메모리에서 읽거나 메모리에 저장할 데이터 자체를 보관하는 버퍼 레지스터

  메모리 계층 구조
    레지스터, 캐시 , 메인 메모리, 보조기억장치
        <- 저용량 / 속도 가격 비쌈

    레지스터 : 프로세서 내부에 존재, 가장 빠른 메모리, 속도가 빠른대신 용량 제한적
    캐시 : 프로세서 내부나 외부에 있으며, 처리 속도가 빠른 프로세서와 상대적으로 느린 메인 메모리의 차이를 보완하는 고속 버퍼
    메인 메모리 : 프로세서 외부에 있으면서 프로세서가 수행할 프로그램과 데이터를 저장하거나
      프로세서에서 처리한 결과 저장, 주기억장치 or 1차 기억장치라고함. 
      프로세서와 보조기억장치 사이에서 있으며, 여기서 발생하는 디스크 입출력 병목 현상을 해결하는 역할
    보조기억장치 : 주변장치 중 프로그램과 데이터를 저장하는 하드웨어, 2차 기억장치 or 외부기억장치라고함
      종류로는 자기디스크, 광디스크, 자기테이프 등이 있음

  명령어 구조
    연산부호(opcode) + 피연산자 n개(operand)
    명령부              주소부

  직접주소와 간접 주소
    직접 주소: 피연산자에 데이터가 있는 레지스터나 메모리 주소 지정
    간접 주소: 레지스터나 메모리 주소 정보 지정

  명령어의 실행 과정
    1. 명령어 인출
    2. 명령어 해석, 프로그램 카운터 변경
    3. 피연산자 인출
    4. 명령어 실행
    5. 결과 저장

    인출 사이클 : 메모리에서 명렁어를 읽어 명렁어 레지스터에 저장하고 다음 명령어를 실행하려고 프로그램 카운터(PC 증가)
      이 사이클에 소요되는 시간을 명령어 인출 시간이라 함
    실행 사이클 : 인출한 명령어를 해독하고 그 결과에 따라 제어 신호를 발생시켜 명령어 실행, 이에 소비되는 시간을 실행 시간이라함
    간접 사이클 : 간접 주소 지정 방법을 사용하는 실행 사이클
    인터럽트 사이클 : 프로세서가 실행 사이클 완료 후 인터럽트 요구가 있는지 확인, 있다면 현재 수행 중인 프로그램의 주소
      값을 스택이나 메모리의 0번지와 같은 특정 장소에 저장. 이후 인터럽트 처리 완료 후 중단된 프로그램으로 복귀 후 계속 수행

  **인터럽트
    현재 실행중인 프로그램을 종료하고 다른 프로그램의 실행을 요구하는 명령어
    시스템의 처리 효율 향상, 실행 순서를 바꿔가며 처리하여 다중 프로그래밍에 사용
    예상치 못한 사용자 입력, 갑작스런 정전, 컴퓨터 시스템에서 긴급 요청, 잘못된 명령어 수행 같은 상황을 시스템이 적절히 처리하는데 필요함.

    인터럽트 요청
      단일 회선
        인터럽트 요청이 가능한 모든 장치를 공통의 단일 회선으로 프로세서에 연결하는 방법(요청 장치 판별 기능 필요)
      다중 회선:
        모든 장치를 서로 다른 고유의 회선으로 프로세서와 연결하는 방법(판별 장치 필요x)

(week6)
  교착 상태
    발생조건
      1. 상호배제
        자원을 최소 하나 이상 비공유해야 함. 즉 한번에 프로세스 하나만 해당 자원 사용가능해야함
      2. 점유와 대기
        자원을 최소한 하나는 보유(점유)하고, 다른 프로세스에 할당된 자원을 얻으려고 기다리는 프로세스가 있어야한다.
      3. 비선점
        자원은 선점할 수 없다(실행 중인 프로세스의 자원을 뻇을 수 없음)
      4. 순환(환형) 대기
        대기 프로세스가 존재할때 a가 b의 자원을 b가 c의 자원을 c가 a의 자원을 얻으려 기다리는 것을 순환대기라고함 (사이클)
      여기서 1~3번만 만족해도 교착 상태는 발생가능, 물론 조건을 만족한다고 반드시 교착 상태가 되는 것은 아님.
      그리고 교착상태가 되려면 사이클이 있어야하나 사이클이 있다고 무조건 교착상태는 아님.
  
    해결방법  (여기서 논술문제 나올만한데?)
      1. 발생하지 않도록 예방
        1. 자원의 상호배제 조건 방지
        2. 점유와 대기 조건 방지
        3. 비선점 조건 방지
        4. 순환(환영) 대기 조건 방지
        (발생조건의 반대)
  
          예방시 고려해야할 규칙
            각 프로세스는 오름차순으로만 자원들을 요청할 수 있다(계층적 요청은 순환 대기 조건 가능성을
            제거하여 교착 상태를 예방하지만 자원의 번호 순서대로 요청해야한다는 부담이 존재)
  
      2. 발생 가능성을 배제하지 않고 적절히 회피
        1. 프로세스의 시작 중단
          프로세스의 요구가 교착 상태를 발생시킬 수 있다면 프로세스의 시작을 중단한다.
        2. 자원 할당 거부(은행가 알고리즘)
          프로세스가 요청한 자원을 할당했을 때 교착 상태가 발생할 수 있다면 요청한 자원을 할당하지 않음

      3. 교착 상태를 허용하되 교착 상태를 탐지하여 다시 회복하는 방법(2가지 알고리즘이 필요), 자주 실행하면 기능이 떨어지나
        교착 상태에 빠진 알고리즘을 빨리 발견 가능
        1. 교착 상태 탐지 알고리즘
          탐지 알고리즘 호출
            교착 상태가 자주 발생하면 탐지 알고리즘도 더 자주 호출
            어떤 프로세스라도 허용할 수 없는 요청 하면 즉시 교착 상태. 요청할 때마다 교착 상태 탐지 알고리즘
              호출하면 교착 상태 회피 가능하나 연산 시간 부담, 경제적인 방법은 호출 빈도를 줄임(일정 기간마다 혹은 cpu이용률이 적을때)
            
        2. 교착 상태에서 회복시키는 알고리즘 (여기 아직 정리 못함 어렵넹:;;)
          회복 방법
            프로 세스 중단
            자원 선점


  
